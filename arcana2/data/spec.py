from arcana2.data.tree import TreeLevel
from enum import Enum
from arcana2.exceptions import ArcanaNameError
from .base import FileGroupMixin, FieldMixin, DataMixin
from .item import FileGroup, Field
from .column import FileGroupColumn, FieldColumn

class Salience(Enum):
    """An enum that holds the salience levels options that can be used when
    specifying a file-group or field.
    """
    
    primary = (5, 'Primary input data or difficult to regenerate derivs. e.g. '
               'from scanner reconstruction')
    publication = (4, 'Results that would typically be used as main '
                   'outputs in publications')
    supporting = (3, 'Derivatives that would typically only be kept to support'
                  ' the main results')
    qa = (2, 'Derivatives that would typically be only kept for quality '
          'assurance of analysis workflows')
    debug = (1, 'Derivatives that would typically only need to be checked '
             'when debugging analysis workflows')
    temp = (0, "Temporary data")

    def __init__(self, level, desc):
        self.level = level
        self.desc = desc

    def __lt__(self, other):
        return self.level < other.level

    def __le__(self, other):
        return self.level <= other.level

    def __str__(self):
        return self.name


class DataSpec():

    def __init__(self, name, desc, salience, category):
        self.name = name
        self.desc = desc
        self.salience = salience
        self.category = category

    def __eq__(self, other):
        return (self.name == other.name and self.desc == other.desc
                and self.salience == other.salience
                and self.category == other.category)

    def __hash__(self):
        return (hash(self.name) ^ hash(self.desc) ^ hash(self.salience)
                ^ hash(self.category))

    def initkwargs(self):
        dct = {}
        dct['name'] = self.name
        dct['desc'] = self.desc
        dct['salience'] = self.salience
        dct['category'] = self.category
        return dct

    def find_mismatch(self, other, indent=''):
        mismatch = ''
        sub_indent = indent + '  '
        if self.name != other.name:
            mismatch += ('\n{}name: self={} v other={}'
                         .format(sub_indent, self.name, other.name))
        if self.desc != other.desc:
            mismatch += ('\n{}desc: self={} v other={}'
                         .format(sub_indent, self.desc, other.desc))
        if self.salience != other.salience:
            mismatch += ('\n{}salience: self={} v other={}'
                         .format(sub_indent, self.salience, other.salience))
        if self.category != other.category:
            mismatch += ('\n{}category: self={} v other={}'
                         .format(sub_indent, self.category, other.category))
        return mismatch


class FileGroupSpec(FileGroupMixin, DataSpec):
    """
    A specification for a file group within a analysis to be derived from a
    processing pipeline.

    Parameters
    ----------
    name : str
        The name the file group will be stored under in the dataset
    format : FileFormat
        The file format used to store the file_group. Can be one of the
        recognised formats
    tree_level : TreeLevel
        The level within the dataset tree that the data items sit, i.e. 
        per 'session', 'subject', 'visit', 'group_visit', 'group' or 'dataset'
    desc : str
        Description of what the field represents
    namespace : str
        The namespace within the tree node that the file-group is placed. Used
        to separate derivatives generated by different pipelines and analyses
    salience : Salience
        The salience of the specified file-group, i.e. whether it would be
        typically of interest for publication outputs or whether it is just
        a temporary file in a workflow, and stages in between
    category : str
        A name for a category of file_group specs. Used improve human searching of
        available options
    converters : Dict[FileFormat, pydra.task]
        A dictionary of converter tasks that can be used to implicitly convert
        inputs supplied in alternative formats into the format specified by
        the specification.
    """

    is_spec = True
    ColumnClass = FileGroupColumn

    def __init__(self, name, format, tree_level=TreeLevel.session, desc=None,
                 namespace=None, salience=None, category=None,
                 converters=None):
        DataSpec.__init__(self, name, desc, salience, category)
        FileGroupMixin.__init__(self, format, tree_level, namespace)
        self.converters = converters if converters else {}

    def __eq__(self, other):
        return (FileGroupMixin.__eq__(self, other)
                and DataSpec.__eq__(self, other)
                and self.converters == other.converters)

    def __hash__(self):
        return (FileGroupMixin.__hash__(self)
                ^ DataSpec.__hash__(self)
                ^ hash(self.converters))

    def initkwargs(self):
        dct = FileGroupMixin.initkwargs(self)
        dct.update(DataSpec.initkwargs(self))
        dct['converters'] = self.converters
        return dct

    def __repr__(self):
        return (f"FileGroupSpec(name={self.name}, format={self.format}, "
                f"tree_level={self.tree_level}, namespace={self.namespace}")

    def find_mismatch(self, other, indent=''):
        sub_indent = indent + '  '
        mismatch = FileGroupMixin.find_mismatch(self, other, indent)
        mismatch += DataSpec.find_mismatch(self, other, indent)
        if self.converters != other.converters:
            mismatch += ('\n{}converters: self={} v other={}'
                         .format(sub_indent, list(self.converters),
                                 list(other.converters)))
        return mismatch

    def item(self, node, **kwargs):
        try:
            file_group = node.file_group(self.name,
                                         namespace=self.namespace,
                                         format=self.format)
        except ArcanaNameError:
            # For file_groups that can be generated by the analysis
            file_group = FileGroup(self.name, format=self.format,
                              tree_level=self.tree_level, path=None,
                              subject_id=node.subject_id,
                              visit_id=node.visit_id,
                              dataset=node.dataset,
                              namespace=self.namespace,
                              exists=False,
                              **kwargs)
        return file_group

    def column(self, tree, **kwargs):
        return FileGroupColumn(
            self.name,
            (self.item(n, **kwargs) for n in tree.nodes(self.tree_level)),
            tree_level=self.tree_level,
            format=self.format)


class FieldSpec(FieldMixin, DataSpec):
    """
    An abstract base class representing the specification for a derived
    file_group.

    Parameters
    ----------
    name : str
        The name the field stored as within the dataset
    dtype : type
        The datatype of the value. Can be one of (float, int, str)
    tree_level : TreeLevel
        The level within the dataset tree that the data items sit, i.e. 
        per 'session', 'subject', 'visit', 'group_visit', 'group' or 'dataset'
    array : bool
        Whether the field is an array of values rather than a singleton
    desc : str
        Description of what the field represents
    namespace : str
        The namespace within the tree node that the file-group is placed. Used
        to separate derivatives generated by different pipelines and analyses
    salience : Salience
        The salience of the specified file-group, i.e. whether it would be
        typically of interest for publication outputs or whether it is just
        a temporary file in a workflow, and stages in between        
    category : str
        A name for a category of field specs. Used improve human searching of
        available options
    """

    is_spec = True
    ColumnClass = FieldColumn

    def __init__(self, name, dtype, tree_level=TreeLevel.session, array=False,
                 desc=None, namespace=None, salience=None, category=None):
        FieldMixin.__init__(self, name, dtype, tree_level, namespace,
                            array=array)
        DataSpec.__init__(self, name, desc, salience, category)

    def __eq__(self, other):
        return (FieldMixin.__eq__(self, other)
                and DataSpec.__eq__(self, other))

    def __hash__(self):
        return (FieldMixin.__hash__(self) ^ DataSpec.__hash__(self))

    def find_mismatch(self, other, indent=''):
        mismatch = FieldMixin.find_mismatch(self, other, indent)
        mismatch += DataSpec.find_mismatch(self, other, indent)
        return mismatch

    def __repr__(self):
        return (f"{self.__class__.__name__}(name='{self.name}', "
                f"dtype={self.dtype}, tree_level={self.tree_level}, "
                f"array={self.array})")

    def initkwargs(self):
        dct = FieldMixin.initkwargs(self)
        dct.update(DataSpec.initkwargs(self))
        return dct

    def item(self, node, **kwargs):
        try:
            field = node.field(self.name, namespace=self.namespace)
        except ArcanaNameError:
            # For fields to be generated by the analysis
            field = Field(self.name, dtype=self.dtype,
                          tree_level=self.tree_level,
                          subject_id=node.subject_id,
                          visit_id=node.visit_id,
                          dataset=node.tree.dataset,
                          namespace=self.namespace,
                          array=self.array,
                          exists=False, **kwargs)
        return field

    def column(self, tree, **kwargs):
        return FieldColumn(
            self.name,
            (self.item(n, **kwargs) for n in tree.nodes(self.tree_level)),
            tree_level=self.tree_level,
            dtype=self.dtype,
            array=self.array)
