from enum import Enum
from .base import FileGroupMixin, FieldMixin



class DataSpec():

    def __init__(self, desc, salience, category, frequency):
        self.desc = desc
        self.salience = salience
        self.category = category
        self.frequency = frequency

    def __eq__(self, other):
        return (self.desc == other.desc
                and self.frequency == other.frequency
                and self.salience == other.salience
                and self.category == other.category)

    def __hash__(self):
        return (hash(self.desc) ^ hash(self.salience) ^ hash(self.frequency) ^
                hash(self.category))

    def initkwargs(self):
        dct = {}
        dct['desc'] = self.desc
        dct['salience'] = self.salience
        dct['category'] = self.category
        dct['frequency'] = self.frequency
        return dct

    def find_mismatch(self, other, indent=''):
        mismatch = ''
        sub_indent = indent + '  '
        if self.desc != other.desc:
            mismatch += ('\n{}desc: self={} v other={}'
                         .format(sub_indent, self.desc, other.desc))
        if self.salience != other.salience:
            mismatch += ('\n{}salience: self={} v other={}'
                         .format(sub_indent, self.salience, other.salience))
        if self.category != other.category:
            mismatch += ('\n{}category: self={} v other={}'
                         .format(sub_indent, self.category, other.category))
        if self.frequency != other.frequency:
            mismatch += ('\n{}frequency: self={} v other={}'
                         .format(sub_indent, self.frequency,
                                 other.frequency))
        return mismatch

class FileGroupSpec(FileGroupMixin, DataSpec):
    """
    A specification for a file group within a analysis to be derived from a
    processing pipeline.

    Parameters
    ----------
    path : str
        The path to the relative location of the file groups in the dataset,
        i.e. excluding the node where it is located within the tree
    format : FileFormat
        The file format used to store the file_group. Can be one of the
        recognised formats
    frequency : DataFrequency
        The frequency of the file-group within the dataset tree, e.g. per
        'session', 'subject', 'timepoint', 'group', 'dataset'
    desc : str
        Description of what the field represents
    namespace : str
        The namespace within the tree node that the file-group is placed. Used
        to separate derivatives generated by different pipelines and analyses
    salience : Salience
        The salience of the specified file-group, i.e. whether it would be
        typically of interest for publication outputs or whether it is just
        a temporary file in a workflow, and stages in between
    category : str
        A name for a category of file_group specs. Used improve human searching of
        available options
    converters : Dict[FileFormat, pydra.task]
        A dictionary of converter tasks that can be used to implicitly convert
        inputs supplied in alternative formats into the format specified by
        the specification.
    """

    is_spec = True

    def __init__(self, path, format, frequency, desc=None, salience=None,
                 category=None, converters=None):
        FileGroupMixin.__init__(self, path, format)
        DataSpec.__init__(self,desc, salience, category, frequency)
        self.converters = converters if converters else {}

    def __eq__(self, other):
        return (FileGroupMixin.__eq__(self, other)
                and DataSpec.__eq__(self, other)
                and self.converters == other.converters)

    def __hash__(self):
        return (FileGroupMixin.__hash__(self)
                ^ DataSpec.__hash__(self)
                ^ hash(self.converters))

    def initkwargs(self):
        dct = FileGroupMixin.initkwargs(self)
        dct.update(DataSpec.initkwargs(self))
        dct['converters'] = self.converters
        return dct

    def __repr__(self):
        return (f"FileGroupSpec(path={self.path}, format={self.format}, "
                f"frequency={self.frequency}")

    def find_mismatch(self, other, indent=''):
        sub_indent = indent + '  '
        mismatch = FileGroupMixin.find_mismatch(self, other, indent)
        mismatch += DataSpec.find_mismatch(self, other, indent)
        if self.converters != other.converters:
            mismatch += ('\n{}converters: self={} v other={}'
                         .format(sub_indent, list(self.converters),
                                 list(other.converters)))
        return mismatch


class FieldSpec(FieldMixin, DataSpec):
    """
    An abstract base class representing the specification for a derived
    file_group.

    Parameters
    ----------
    path : str
        The path to the relative location the fields, i.e. excluding
        information about which node in the data tree it belongs to
    dtype : type
        The datatype of the value. Can be one of (float, int, str)
    frequency : DataFrequency
       The frequency of the field within the dataset tree, e.g. per
        'session', 'subject', 'timepoint', 'group', 'dataset'
    array : bool
        Whether the field is an array of values rather than a singleton
    desc : str
        Description of what the field represents
    namespace : str
        The namespace within the tree node that the file-group is placed. Used
        to separate derivatives generated by different pipelines and analyses
    salience : Salience
        The salience of the specified file-group, i.e. whether it would be
        typically of interest for publication outputs or whether it is just
        a temporary file in a workflow, and stages in between        
    category : str
        A name for a category of field specs. Used improve human searching of
        available options
    """

    is_spec = True

    def __init__(self, path, dtype, frequency, array=False,
                 desc=None, salience=None, category=None):
        FieldMixin.__init__(self, path, dtype, array)
        DataSpec.__init__(self, desc, salience, category, frequency)

    def __eq__(self, other):
        return (FieldMixin.__eq__(self, other)
                and DataSpec.__eq__(self, other))

    def __hash__(self):
        return (FieldMixin.__hash__(self) ^ DataSpec.__hash__(self))

    def find_mismatch(self, other, indent=''):
        mismatch = FieldMixin.find_mismatch(self, other, indent)
        mismatch += DataSpec.find_mismatch(self, other, indent)
        return mismatch

    def __repr__(self):
        return (f"{self.__class__.__name__}(path='{self.path}', "
                f"dtype={self.dtype}, frequency={self.frequency}, "
                f"array={self.array})")

    def initkwargs(self):
        dct = FieldMixin.initkwargs(self)
        dct.update(DataSpec.initkwargs(self))
        return dct

class Salience(Enum):
    """An enum that holds the salience levels options that can be used when
    specifying data. Salience is used to indicate whether it would be best to
    store the data in the data repository or whether it can be just stored in
    the local file-system and discarded after it has been used. This choice
    is ultimately specified by the user by defining a salience threshold for
    a repository.

    The salience is also used when providing information on what derivatives
    are available to avoid cluttering help menus
    """
    
    primary = (5, 'Primary input data, e.g. data from scanner')
    publication = (4, 'Results that would typically be used as main '
                   'outputs in publications')
    supporting = (3, 'Derivatives that would typically only be kept to support'
                  ' the main results')
    qa = (2, 'Derivatives that would typically be only kept for quality '
          'assurance of analysis workflows')
    debug = (1, 'Derivatives that would typically only need to be checked '
             'when debugging analysis workflows')
    temp = (0, "Data only temporarily stored to pass between pipelines")

    def __init__(self, level, desc):
        self.level = level
        self.desc = desc

    def __lt__(self, other):
        return self.level < other.level

    def __le__(self, other):
        return self.level <= other.level

    def __str__(self):
        return self.name
